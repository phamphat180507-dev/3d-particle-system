<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>3D Multi-Model Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #controls { position: absolute; top: 20px; left: 20px; z-index: 100; display: flex; gap: 10px; }
        button { background: rgba(0, 212, 255, 0.2); border: 1px solid #00d4ff; color: #00d4ff; padding: 10px 15px; cursor: pointer; border-radius: 5px; transition: 0.3s; }
        button:hover { background: #00d4ff; color: black; }
        #status { position: absolute; top: 70px; left: 20px; color: white; font-size: 14px; opacity: 0.7; }
        #video-container { position: absolute; bottom: 10px; right: 10px; width: 150px; opacity: 0.3; transform: scaleX(-1); border-radius: 10px; overflow: hidden; }
        video { width: 100%; display: block; }
    </style>
</head>
<body>
    <div id="controls">
        <button onclick="setMode('particles')">Chế độ Hạt</button>
        <button onclick="setMode('neural')">Chế độ Mạng lưới</button>
    </div>
    <div id="status">Đang tải MediaPipe...</div>
    <div id="video-container"><video id="webcam" autoplay></video></div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Cấu hình chung ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.z = 8;

        let mode = 'particles'; 
        const handData = { x: 0, y: 0, isGrabbing: false, active: false };

        // 1. Khởi tạo Hạt (Mode 1)
        const pCount = 8000;
        const pGeometry = new THREE.BufferGeometry();
        const pPos = new Float32Array(pCount * 3);
        for(let i=0; i<pCount*3; i++) pPos[i] = (Math.random()-0.5)*15;
        pGeometry.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        const pMaterial = new THREE.PointsMaterial({ size: 0.02, color: 0x00d4ff, blending: THREE.AdditiveBlending });
        const pMesh = new THREE.Points(pGeometry, pMaterial);
        scene.add(pMesh);

        // 2. Khởi tạo Mạng lưới (Mode 2)
        const nCount = 150;
        const nGeometry = new THREE.BufferGeometry();
        const nPos = new Float32Array(nCount * 3);
        for(let i=0; i<nCount*3; i++) nPos[i] = (Math.random()-0.5)*15;
        nGeometry.setAttribute('position', new THREE.BufferAttribute(nPos, 3));
        const nLinesGeom = new THREE.BufferGeometry();
        const nLinesMat = new THREE.LineBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.3 });
        const nLines = new THREE.LineSegments(nLinesGeom, nLinesMat);
        scene.add(nLines);
        nLines.visible = false;

        window.setMode = (m) => {
            mode = m;
            pMesh.visible = (m === 'particles');
            nLines.visible = (m === 'neural');
        };

        // --- Hand Tracking ---
        async function initHand() {
            const hands = new window.Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.7});
            hands.onResults(res => {
                if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                    handData.active = true;
                    const lm = res.multiHandLandmarks[0];
                    const d = Math.sqrt(Math.pow(lm[8].x-lm[0].x,2)+Math.pow(lm[8].y-lm[0].y,2));
                    handData.isGrabbing = d < 0.3;
                    handData.x = (1-lm[9].x)*2-1; handData.y = -(lm[9].y*2-1);
                    document.getElementById('status').innerText = handData.isGrabbing ? "HÀNH ĐỘNG: NẮM (HÚT)" : "HÀNH ĐỘNG: XÒE (ĐẨY)";
                } else { handData.active = false; document.getElementById('status').innerText = "HÃY GIƠ TAY"; }
            });

            const vid = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({video: true});
            vid.srcObject = stream;
            const cam = new window.Camera(vid, {onFrame: async () => await hands.send({image: vid}), width: 640, height: 480});
            cam.start();
        }

        function animate() {
            requestAnimationFrame(animate);
            const hx = handData.x * 8, hy = handData.y * 6;
            
            if (mode === 'particles') {
                const pos = pGeometry.attributes.position.array;
                for(let i=0; i<pCount; i++) {
                    let ix=i*3, iy=i*3+1;
                    let dx = pos[ix]-hx, dy = pos[iy]-hy;
                    let dist = Math.sqrt(dx*dx+dy*dy);
                    if(handData.active && dist < 3) {
                        let f = handData.isGrabbing ? -0.08 : 0.15;
                        pos[ix] += dx*f; pos[iy] += dy*f;
                    }
                }
                pGeometry.attributes.position.needsUpdate = true;
            } else {
                const pos = nGeometry.attributes.position.array;
                const linePoints = [];
                for(let i=0; i<nCount; i++) {
                    let ix=i*3, iy=i*3+1;
                    pos[ix] += Math.sin(Date.now()*0.001+i)*0.005;
                    if(handData.active) {
                        let dx=pos[ix]-hx, dy=pos[iy]-hy;
                        if(Math.sqrt(dx*dx+dy*dy)<4) {
                            let f = handData.isGrabbing ? -0.02 : 0.01;
                            pos[ix]+=dx*f; pos[iy]+=dy*f;
                        }
                    }
                    for(let j=i+1; j<nCount; j++) {
                        let jx=j*3, jy=j*3+1, jz=j*3+2;
                        let dist = Math.sqrt(Math.pow(pos[ix]-pos[jx],2)+Math.pow(pos[iy]-pos[jy],2));
                        if(dist < 2.5) {
                            linePoints.push(pos[ix], pos[iy], pos[i*3+2], pos[jx], pos[jy], pos[jz]);
                        }
                    }
                }
                nLinesGeom.setAttribute('position', new THREE.Float32BufferAttribute(linePoints, 3));
                nGeometry.attributes.position.needsUpdate = true;
            }
            renderer.render(scene, camera);
        }

        const load = (src) => new Promise(res => { const s=document.createElement('script'); s.src=src; s.onload=res; document.head.appendChild(s); });
        async function start() {
            await load("https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js");
            await load("https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js");
            initHand(); animate();
        }
        start();
    </script>
</body>
</html>
